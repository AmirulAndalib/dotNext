<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Benchmarks | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Benchmarks | .NEXT ">
    <meta name="generator" content="docfx 2.58.4.0">
    
    <link rel="shortcut icon" href="fav.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="benchmarks">Benchmarks</h1>

<p>Microbenchmarks are important part of DotNext library to prove than important features can speed up performance of your application or, at least, is not slowing down it.</p>
<p>The configuration of all benchmarks:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>.NET 6.0.0 (6.0.21.45113), X64 RyuJIT, X64 RyuJIT</td>
</tr>
<tr>
<td>Job</td>
<td>.NET 6.0.0 (6.0.21.45113), X64 RyuJIT, X64 RyuJIT</td>
</tr>
<tr>
<td>LaunchCount</td>
<td>1</td>
</tr>
<tr>
<td>RunStrategy</td>
<td>Throughput</td>
</tr>
<tr>
<td>OS</td>
<td>Ubuntu 20.04.2</td>
</tr>
<tr>
<td>CPU</td>
<td>Intel Core i7-6700HQ CPU 2.60GHz (Skylake)</td>
</tr>
<tr>
<td>Number of CPUs</td>
<td>1</td>
</tr>
<tr>
<td>Physical Cores</td>
<td>4</td>
</tr>
<tr>
<td>Logical Cores</td>
<td>8</td>
</tr>
<tr>
<td>RAM</td>
<td>24 GB</td>
</tr>
</tbody>
</table>
<p>You can run benchmarks using <code>Bench</code> build configuration as follows:</p>
<pre><code class="lang-bash">cd &lt;dotnext-clone-path&gt;/src/DotNext.Benchmarks
dotnet run -c Bench
</code></pre>
<h1 id="bitwise-equality">Bitwise Equality</h1>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/BitwiseEqualityBenchmark.cs">This benchmark</a> compares performance of <a class="xref" href="api/DotNext.BitwiseComparer-1.html">BitwiseComparer&lt;T&gt;.Equals</a> with overloaded equality <code>==</code> operator. Testing data types: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.guid">Guid</a> and custom value type with multiple fields.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Guid.Equals</code></td>
<td style="text-align: right;">1.5397 ns</td>
<td style="text-align: right;">0.0119 ns</td>
<td style="text-align: right;">0.0106 ns</td>
</tr>
<tr>
<td><code>BitwiseComparer&lt;Guid&gt;.Equals</code></td>
<td style="text-align: right;">4.1342 ns</td>
<td style="text-align: right;">0.0298 ns</td>
<td style="text-align: right;">0.0278 ns</td>
</tr>
<tr>
<td><code>ReadOnlySpan.SequenceEqual</code> for <code>Guid</code></td>
<td style="text-align: right;">5.9180 ns</td>
<td style="text-align: right;">0.0390 ns</td>
<td style="text-align: right;">0.0365 ns</td>
</tr>
<tr>
<td><code>BitwiseComparer&lt;LargeStruct&gt;.Equals</code></td>
<td style="text-align: right;">9.7704 ns</td>
<td style="text-align: right;">0.0489 ns</td>
<td style="text-align: right;">0.0434 ns</td>
</tr>
<tr>
<td><code>ReadOnlySpan.SequenceEqual</code> for <code>LargeStruct</code></td>
<td style="text-align: right;">10.4140 ns</td>
<td style="text-align: right;">0.0742 ns</td>
<td style="text-align: right;">0.0694 ns</td>
</tr>
<tr>
<td><code>LargeStruct.Equals</code></td>
<td style="text-align: right;">33.9465 ns</td>
<td style="text-align: right;">0.2037 ns</td>
<td style="text-align: right;">0.1805 ns</td>
</tr>
</tbody>
</table>
<p>Bitwise equality method has the better performance than field-by-field equality check especially for large value types because <code>BitwiseEquals</code> utilizes low-level optimizations performed by .NET according with underlying hardware such as SIMD. Additionally, it uses <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">aligned memory access</a> in constrast to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal">SequenceEqual</a> method.</p>
<h1 id="equality-of-arrays">Equality of Arrays</h1>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/ArrayEqualityBenchmark.cs">This benchmark</a> compares performance of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal#System_MemoryExtensions_SequenceEqual__1_System_ReadOnlySpan___0__System_ReadOnlySpan___0__">ReadOnlySpan.SequenceEqual</a>, <a class="xref" href="api/DotNext.OneDimensionalArray.html">OneDimensionalArray.BitwiseEquals</a> and manual equality check between two arrays using <code>for</code> loop. The benchmark is applied to the array of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.guid">Guid</a> elements.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Guid[].BitwiseEquals</code>, small array (~10 elements)</td>
<td style="text-align: right;">7.333 ns</td>
<td style="text-align: right;">0.0556 ns</td>
<td style="text-align: right;">0.0520 ns</td>
</tr>
<tr>
<td><code>ReadOnlySpan&lt;Guid&gt;.SequenceEqual</code>, small array (~10 elements)</td>
<td style="text-align: right;">34.068 ns</td>
<td style="text-align: right;">0.6565 ns</td>
<td style="text-align: right;">0.6141 ns</td>
</tr>
<tr>
<td><code>for</code> loop, small array (~10 elements)</td>
<td style="text-align: right;">35.471 ns</td>
<td style="text-align: right;">0.3395 ns</td>
<td style="text-align: right;">0.2835 ns</td>
</tr>
<tr>
<td><code>Guid[].BitwiseEquals</code>, large array (~100 elements)</td>
<td style="text-align: right;">44.753 ns</td>
<td style="text-align: right;">0.1101 ns</td>
<td style="text-align: right;">0.1030 ns</td>
</tr>
<tr>
<td><code>ReadOnlySpan&lt;Guid&gt;.SequenceEqual</code>, large array (~100 elements)</td>
<td style="text-align: right;">318.775 ns</td>
<td style="text-align: right;">1.2861 ns</td>
<td style="text-align: right;">1.1401 ns</td>
</tr>
<tr>
<td><code>for</code> loop, large array (~100 elements)</td>
<td style="text-align: right;">337.962 ns</td>
<td style="text-align: right;">1.4221 ns</td>
<td style="text-align: right;">1.2606 ns</td>
</tr>
</tbody>
</table>
<p>Bitwise equality is an absolute winner for equality check between arrays of any size.</p>
<h1 id="bitwise-hash-code">Bitwise Hash Code</h1>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/BitwiseHashCodeBenchmark.cs">This benchmark</a> compares performance of <a class="xref" href="api/DotNext.BitwiseComparer-1.html">BitwiseComparer&lt;T&gt;.GetHashCode</a> and <code>GetHashCode</code> instance method for the types <a href="https://docs.microsoft.com/en-us/dotnet/api/system.guid">Guid</a> and custom value type with multiple fields.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Guid.GetHashCode</code></td>
<td style="text-align: right;">0.6889 ns</td>
<td style="text-align: right;">0.0085 ns</td>
<td style="text-align: right;">0.0076 ns</td>
</tr>
<tr>
<td><code>BitwiseComparer&lt;Guid&gt;.GetHashCode</code></td>
<td style="text-align: right;">6.3194 ns</td>
<td style="text-align: right;">0.0223 ns</td>
<td style="text-align: right;">0.0209 ns</td>
</tr>
<tr>
<td><code>BitwiseComparer&lt;LargeStructure&gt;.GetHashCode</code></td>
<td style="text-align: right;">20.6265 ns</td>
<td style="text-align: right;">0.0839 ns</td>
<td style="text-align: right;">0.0785 ns</td>
</tr>
<tr>
<td><code>LargeStructure.GetHashCode</code></td>
<td style="text-align: right;">43.5677 ns</td>
<td style="text-align: right;">0.1517 ns</td>
<td style="text-align: right;">0.1419 ns</td>
</tr>
</tbody>
</table>
<p>Bitwise hash code algorithm is slower than JIT optimizations introduced by .NET 6 but still convenient in complex cases.</p>
<h1 id="bytes-to-hex">Bytes to Hex</h1>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/HexConversionBenchmark.cs">This benchmark</a> demonstrates performance of <code>DotNext.Span.ToHex</code> extension method that allows to convert arbitrary set of bytes into hexadecimal form. It is compatible with<code>Span&lt;T&gt;</code> data type in constrast to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter.tostring">BitConverter.ToString</a> method.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Bytes</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitConverter.ToString</td>
<td>16 bytes</td>
<td style="text-align: right;">59.81 ns</td>
<td style="text-align: right;">0.379 ns</td>
<td style="text-align: right;">0.296 ns</td>
</tr>
<tr>
<td>Span.ToHex</td>
<td>16 bytes</td>
<td style="text-align: right;">54.27 ns</td>
<td style="text-align: right;">0.754 ns</td>
<td style="text-align: right;">0.705 ns</td>
</tr>
<tr>
<td>BitConverter.ToString</td>
<td>64 bytes</td>
<td style="text-align: right;">195.29 ns</td>
<td style="text-align: right;">1.175 ns</td>
<td style="text-align: right;">1.099 ns</td>
</tr>
<tr>
<td>Span.ToHex</td>
<td>64 bytes</td>
<td style="text-align: right;">129.07 ns</td>
<td style="text-align: right;">0.564 ns</td>
<td style="text-align: right;">0.471 ns</td>
</tr>
<tr>
<td>BitConverter.ToString</td>
<td>128 bytes</td>
<td style="text-align: right;">520.31 ns</td>
<td style="text-align: right;">9.848 ns</td>
<td style="text-align: right;">14.740 ns</td>
</tr>
<tr>
<td>Span.ToHex</td>
<td>128 bytes</td>
<td style="text-align: right;">228.17 ns</td>
<td style="text-align: right;">1.084 ns</td>
<td style="text-align: right;">0.961 ns</td>
</tr>
<tr>
<td>BitConverter.ToString</td>
<td>256 bytes</td>
<td style="text-align: right;">1,013.92 ns</td>
<td style="text-align: right;">17.653 ns</td>
<td style="text-align: right;">15.649 ns</td>
</tr>
<tr>
<td>Span.ToHex</td>
<td>256 bytes</td>
<td style="text-align: right;">458.78 ns</td>
<td style="text-align: right;">5.442 ns</td>
<td style="text-align: right;">4.545 ns</td>
</tr>
</tbody>
</table>
<p><code>Span.ToHex</code> demonstrates the best performance especially for large arrays.</p>
<h1 id="fast-reflection">Fast Reflection</h1>
<p>The next series of benchmarks demonstrate performance of strongly typed reflection provided by DotNext Reflection library.</p>
<h2 id="property-getter">Property Getter</h2>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/Reflection/PropertyGetterReflectionBenchmark.cs">This benchmark</a> demonstrates overhead of getting instance property value caused by different mechanisms:</p>
<ol>
<li>Using <a href="https://github.com/mgravell/fast-member">FastMember</a> library</li>
<li>Using strongly typed reflection from DotNext Reflection library: <code>Type&lt;IndexOfCalculator&gt;.Property&lt;int&gt;.RequireGetter</code></li>
<li>Using strongly typed reflection from DotNext Reflection library using special delegate type <code>Function&lt;object, ValueTuple, object&gt;</code>. It is assumed that instance type and property type is not known at compile type (th) so the delegate performs type check on every call.</li>
<li>Classic .NET reflection</li>
</ol>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">RatioSD</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct call</td>
<td style="text-align: right;">11.18 ns</td>
<td style="text-align: right;">0.083 ns</td>
<td style="text-align: right;">0.073 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>MemberGetter&lt;IndexOfCalculator, int&gt;</code></td>
<td style="text-align: right;">11.83 ns</td>
<td style="text-align: right;">0.060 ns</td>
<td style="text-align: right;">0.056 ns</td>
<td style="text-align: right;">1.06</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Reflection with DotNext using <code>DynamicInvoker</code></td>
<td style="text-align: right;">21.46 ns</td>
<td style="text-align: right;">0.131 ns</td>
<td style="text-align: right;">0.122 ns</td>
<td style="text-align: right;">1.92</td>
<td style="text-align: right;">0.02</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;object, ValueTuple, object&gt;</code></td>
<td style="text-align: right;">20.49 ns</td>
<td style="text-align: right;">0.127 ns</td>
<td style="text-align: right;">0.106 ns</td>
<td style="text-align: right;">1.83</td>
<td style="text-align: right;">0.02</td>
</tr>
<tr>
<td>ObjectAccess class from <em>FastMember</em> library</td>
<td style="text-align: right;">41.46 ns</td>
<td style="text-align: right;">0.185 ns</td>
<td style="text-align: right;">0.173 ns</td>
<td style="text-align: right;">3.71</td>
<td style="text-align: right;">0.03</td>
</tr>
<tr>
<td>.NET reflection</td>
<td style="text-align: right;">135.60 ns</td>
<td style="text-align: right;">1.085 ns</td>
<td style="text-align: right;">1.015 ns</td>
<td style="text-align: right;">12.13</td>
<td style="text-align: right;">0.15</td>
</tr>
</tbody>
</table>
<p>Strongly typed reflection provided by DotNext Reflection library has the same performance as direct call.</p>
<h2 id="instance-method-call">Instance Method Call</h2>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/Reflection/StringMethodReflectionBenchmark.cs">This benchmark</a> demonstrates overhead of calling instance method <code>IndexOf</code> of type <strong>string</strong> caused by different mechanisms:</p>
<ol>
<li>Using strongly typed reflection from DotNext Reflection library: <code>Type&lt;string&gt;.Method&lt;char, int&gt;.Require&lt;int&gt;(nameof(string.IndexOf))</code></li>
<li>Using strongly typed reflection from DotNext Reflection library using special delegate type: <code>Type&lt;string&gt;.RequireMethod&lt;(char, int), int&gt;(nameof(string.IndexOf));</code></li>
<li>Using strongly typed reflection from DotNext Reflection library using special delegate type: <code>Function&lt;object, (object, object), object&gt;</code>. It is assumed that types of all parameters are not known at compile time.</li>
<li>Classic .NET reflection</li>
</ol>
<p>The benchmark uses series of different strings to run the same set of tests. Worst case means that character lookup is performed for a string that doesn't contain the given character. Best case means that character lookup is performed for a string that has the given character.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>StringValue</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">RatioSD</th>
</tr>
</thead>
<tbody>
<tr>
<td>.NET reflection</td>
<td></td>
<td style="text-align: right;">267.051 ns</td>
<td style="text-align: right;">0.7739 ns</td>
<td style="text-align: right;">0.6860 ns</td>
<td style="text-align: right;">61.84</td>
<td style="text-align: right;">2.42</td>
</tr>
<tr>
<td>Direct call</td>
<td></td>
<td style="text-align: right;">4.341 ns</td>
<td style="text-align: right;">0.1173 ns</td>
<td style="text-align: right;">0.1483 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Func&lt;string, char, int, int&gt;</code></td>
<td></td>
<td style="text-align: right;">8.694 ns</td>
<td style="text-align: right;">0.0299 ns</td>
<td style="text-align: right;">0.0265 ns</td>
<td style="text-align: right;">2.01</td>
<td style="text-align: right;">0.08</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;object, (object, object), object&gt;</code></td>
<td></td>
<td style="text-align: right;">29.566 ns</td>
<td style="text-align: right;">0.1688 ns</td>
<td style="text-align: right;">0.1496 ns</td>
<td style="text-align: right;">6.85</td>
<td style="text-align: right;">0.26</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;string, (char, int), int&gt;</code></td>
<td></td>
<td style="text-align: right;">12.496 ns</td>
<td style="text-align: right;">0.0556 ns</td>
<td style="text-align: right;">0.0521 ns</td>
<td style="text-align: right;">2.89</td>
<td style="text-align: right;">0.10</td>
</tr>
<tr>
<td>Reflection with DotNext using <code>DynamicInvoker</code></td>
<td></td>
<td style="text-align: right;">27.646 ns</td>
<td style="text-align: right;">0.2521 ns</td>
<td style="text-align: right;">0.2235 ns</td>
<td style="text-align: right;">6.40</td>
<td style="text-align: right;">0.25</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td>.NET reflection</td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">276.495 ns</td>
<td style="text-align: right;">1.3943 ns</td>
<td style="text-align: right;">1.3042 ns</td>
<td style="text-align: right;">38.86</td>
<td style="text-align: right;">0.35</td>
</tr>
<tr>
<td>Direct call</td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">7.111 ns</td>
<td style="text-align: right;">0.0502 ns</td>
<td style="text-align: right;">0.0419 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Func&lt;string, char, int, int&gt;</code></td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">10.947 ns</td>
<td style="text-align: right;">0.0467 ns</td>
<td style="text-align: right;">0.0390 ns</td>
<td style="text-align: right;">1.54</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;object, (object, object), object&gt;</code></td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">30.356 ns</td>
<td style="text-align: right;">0.1505 ns</td>
<td style="text-align: right;">0.1408 ns</td>
<td style="text-align: right;">4.27</td>
<td style="text-align: right;">0.03</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;string, (char, int), int&gt;</code></td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">15.782 ns</td>
<td style="text-align: right;">0.1097 ns</td>
<td style="text-align: right;">0.0972 ns</td>
<td style="text-align: right;">2.22</td>
<td style="text-align: right;">0.02</td>
</tr>
<tr>
<td>Reflection with DotNext using <code>DynamicInvoker</code></td>
<td>abccdahehkgbe387jwgr</td>
<td style="text-align: right;">34.757 ns</td>
<td style="text-align: right;">0.1380 ns</td>
<td style="text-align: right;">0.1223 ns</td>
<td style="text-align: right;">4.89</td>
<td style="text-align: right;">0.03</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td>.NET reflection</td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">268.056 ns</td>
<td style="text-align: right;">1.8884 ns</td>
<td style="text-align: right;">1.6740 ns</td>
<td style="text-align: right;">20.30</td>
<td style="text-align: right;">0.18</td>
</tr>
<tr>
<td>Direct call</td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">13.207 ns</td>
<td style="text-align: right;">0.1005 ns</td>
<td style="text-align: right;">0.0891 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Func&lt;string, char, int, int&gt;</code></td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">13.430 ns</td>
<td style="text-align: right;">0.0718 ns</td>
<td style="text-align: right;">0.0599 ns</td>
<td style="text-align: right;">1.02</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;object, (object, object), object&gt;</code></td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">34.486 ns</td>
<td style="text-align: right;">0.1407 ns</td>
<td style="text-align: right;">0.1175 ns</td>
<td style="text-align: right;">2.61</td>
<td style="text-align: right;">0.02</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;string, (char, int), int&gt;</code></td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">17.992 ns</td>
<td style="text-align: right;">0.0771 ns</td>
<td style="text-align: right;">0.0683 ns</td>
<td style="text-align: right;">1.36</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Reflection with DotNext using <code>DynamicInvoker</code></td>
<td>wfjwk(...)wjbvw [52]</td>
<td style="text-align: right;">35.445 ns</td>
<td style="text-align: right;">0.2010 ns</td>
<td style="text-align: right;">0.1880 ns</td>
<td style="text-align: right;">2.68</td>
<td style="text-align: right;">0.03</td>
</tr>
</tbody>
</table>
<p>DotNext Reflection library offers the best result in case when delegate type exactly matches to the reflected method with small overhead measured in a few nanoseconds.</p>
<h2 id="static-method-call">Static Method Call</h2>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/Reflection/TryParseReflectionBenchmark.cs">This benchmark</a> demonstrates overhead of calling static method <code>TryParse</code> of type <strong>decimal</strong> caused by different mechanisms:</p>
<ol>
<li>Using strongly typed reflection from DotNext Reflection library: <code>Type&lt;decimal&gt;.Method.Get&lt;TryParseDelegate&gt;(nameof(decimal.TryParse), MethodLookup.Static)</code>. The delegate type exactly matches to the reflected method signature: <code>delegate bool TryParseDelegate(string text, out decimal result)</code></li>
<li>Using strongly typed reflection from DotNext Reflection library using special delegate type: <code>Function&lt;(string text, decimal result), bool&gt;</code></li>
<li>Using strongly typed reflection from DotNext Reflection library using special delegate type: <code>Function&lt;(object text, object result), object&gt;</code>. It is assumed that types of all parameters are not known at compile time.</li>
<li>Classic .NET reflection</li>
</ol>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">RatioSD</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reflection with DotNext using delegate type <code>TryParseDelegate</code></td>
<td style="text-align: right;">124.1 ns</td>
<td style="text-align: right;">0.44 ns</td>
<td style="text-align: right;">0.39 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Direct call</td>
<td style="text-align: right;">124.3 ns</td>
<td style="text-align: right;">0.85 ns</td>
<td style="text-align: right;">0.80 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr>
<td>Reflection with DotNext using delegate type <code>Function&lt;(string text, decimal result), bool&gt;</code></td>
<td style="text-align: right;">132.0 ns</td>
<td style="text-align: right;">0.35 ns</td>
<td style="text-align: right;">0.33 ns</td>
<td style="text-align: right;">1.06</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>'Reflection with DotNext using delegate type <code>Function&lt;(object text, object result), object&gt;</code>'</td>
<td style="text-align: right;">144.2 ns</td>
<td style="text-align: right;">0.67 ns</td>
<td style="text-align: right;">0.63 ns</td>
<td style="text-align: right;">1.16</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>Reflection with DotNext using <code>DynamicInvoker</code></td>
<td style="text-align: right;">148.7 ns</td>
<td style="text-align: right;">0.57 ns</td>
<td style="text-align: right;">0.53 ns</td>
<td style="text-align: right;">1.20</td>
<td style="text-align: right;">0.01</td>
</tr>
<tr>
<td>.NET reflection</td>
<td style="text-align: right;">462.6 ns</td>
<td style="text-align: right;">1.25 ns</td>
<td style="text-align: right;">1.11 ns</td>
<td style="text-align: right;">3.72</td>
<td style="text-align: right;">0.03</td>
</tr>
</tbody>
</table>
<p>Strongly typed reflection provided by DotNext Reflection library has the same performance as direct call.</p>
<h1 id="atomic-access-to-arbitrary-value-type">Atomic Access to Arbitrary Value Type</h1>
<p><a href="https://github.com/dotnet/DotNext/blob/master/src/DotNext.Benchmarks/Threading/AtomicContainerBenchmark.cs">This benchmark</a> compares performance of <a class="xref" href="api/DotNext.Threading.Atomic-1.html">Atomic&lt;T&gt;</a> and Synchronized methods. The implementation of the benchmark contains concurrent read/write threads to ensure that lock contention is in place.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>Atomic</td>
<td style="text-align: right;">317.9 us</td>
<td style="text-align: right;">9.36 us</td>
<td style="text-align: right;">86.20 us</td>
<td style="text-align: right;">305.8 us</td>
</tr>
<tr>
<td>Synchronized</td>
<td style="text-align: right;">977.9 us</td>
<td style="text-align: right;">10.77 us</td>
<td style="text-align: right;">98.57 us</td>
<td style="text-align: right;">967.1 us</td>
</tr>
<tr>
<td>SpinLock</td>
<td style="text-align: right;">1,891.5 us</td>
<td style="text-align: right;">58.82 us</td>
<td style="text-align: right;">556.19 us</td>
<td style="text-align: right;">1,772.4 us</td>
</tr>
</tbody>
</table>
<h1 id="file-buffering-writer">File-buffering Writer</h1>
<p><a href="https://github.com/dotnet/dotNext/blob/master/src/DotNext.Benchmarks/IO/FileBufferingWriterBenchmark.cs">This benchmark</a> compares performance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webutilities.filebufferingwritestream">FileBufferingWriteStream</a> from ASP.NET Core and <a class="xref" href="api/DotNext.IO.FileBufferingWriter.html">FileBufferingWriter</a> from .NEXT library.</p>
<p>Both classes switching from in-memory buffer to file-based buffer during benchmark execution. Note that benchmark result highly depends on disk I/O performance. The following results were obtained using NVMe SSD.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Median</th>
</tr>
</thead>
<tbody>
<tr>
<td>'FileBufferingWriter, synchronous mode'</td>
<td style="text-align: right;">1.083 ms</td>
<td style="text-align: right;">0.0147 ms</td>
<td style="text-align: right;">0.0137 ms</td>
<td style="text-align: right;">1.089 ms</td>
</tr>
<tr>
<td>'FileBufferingWriter, asynchronous mode'</td>
<td style="text-align: right;">1.532 ms</td>
<td style="text-align: right;">0.0501 ms</td>
<td style="text-align: right;">0.1477 ms</td>
<td style="text-align: right;">1.447 ms</td>
</tr>
<tr>
<td>'FileBufferingWriteStream, synchronouse mode'</td>
<td style="text-align: right;">4.251 ms</td>
<td style="text-align: right;">0.0434 ms</td>
<td style="text-align: right;">0.0385 ms</td>
<td style="text-align: right;">4.242 ms</td>
</tr>
<tr>
<td>'FileBufferingWriteStream, asynchronous mode'</td>
<td style="text-align: right;">5.127 ms</td>
<td style="text-align: right;">0.0683 ms</td>
<td style="text-align: right;">0.0639 ms</td>
<td style="text-align: right;">5.106 ms</td>
</tr>
</tbody>
</table>
<p><code>FileBufferingWriter</code> is a winner in synchronous scenario because it has native support for synchronous mode in contrast to <code>FileBufferingWriteStream</code>.</p>
<h1 id="various-buffer-types">Various Buffer Types</h1>
<p><a href="https://github.com/dotnet/dotNext/blob/master/src/DotNext.Benchmarks/Buffers/MemoryStreamingBenchmark.cs">This benchmark</a> demonstrates the performance of write operation and memory consumption of the following types:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream">MemoryStream</a></li>
<li><a href="https://github.com/microsoft/Microsoft.IO.RecyclableMemoryStream">RecyclableMemoryStream</a></li>
<li><a class="xref" href="api/DotNext.Buffers.SparseBufferWriter-1.html">SparseBufferWriter&lt;byte&gt;</a></li>
<li><a class="xref" href="api/DotNext.Buffers.PooledArrayBufferWriter-1.html">PooledArrayBufferWriter&lt;byte&gt;</a></li>
<li><a class="xref" href="api/DotNext.IO.FileBufferingWriter.html">FileBufferingWriter</a></li>
</ul>
<table>
<thead>
<tr>
<th>Buffer Type</th>
<th>TotalCount</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">RatioSD</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Gen 1</th>
<th style="text-align: right;">Gen 2</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MemoryStream</code></td>
<td>100</td>
<td style="text-align: right;">60.39 ns</td>
<td style="text-align: right;">0.674 ns</td>
<td style="text-align: right;">0.598 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.1097</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">344 B</td>
</tr>
<tr>
<td><code>PooledArrayBufferWriter&lt;byte&gt;</code></td>
<td>100</td>
<td style="text-align: right;">171.04 ns</td>
<td style="text-align: right;">0.719 ns</td>
<td style="text-align: right;">0.672 ns</td>
<td style="text-align: right;">2.83</td>
<td style="text-align: right;">0.03</td>
<td style="text-align: right;">0.0355</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;byte&gt;</code></td>
<td>100</td>
<td style="text-align: right;">240.96 ns</td>
<td style="text-align: right;">2.217 ns</td>
<td style="text-align: right;">1.731 ns</td>
<td style="text-align: right;">3.99</td>
<td style="text-align: right;">0.05</td>
<td style="text-align: right;">0.0610</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">192 B</td>
</tr>
<tr>
<td><code>FileBufferingWriter</code></td>
<td>100</td>
<td style="text-align: right;">2,230.30 ns</td>
<td style="text-align: right;">14.776 ns</td>
<td style="text-align: right;">13.822 ns</td>
<td style="text-align: right;">36.95</td>
<td style="text-align: right;">0.49</td>
<td style="text-align: right;">0.0343</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>RecyclableMemoryStream</code></td>
<td>100</td>
<td style="text-align: right;">2,418.88 ns</td>
<td style="text-align: right;">13.071 ns</td>
<td style="text-align: right;">11.587 ns</td>
<td style="text-align: right;">40.06</td>
<td style="text-align: right;">0.39</td>
<td style="text-align: right;">0.1183</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">376 B</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td><code>MemoryStream</code></td>
<td>1000</td>
<td style="text-align: right;">114.40 ns</td>
<td style="text-align: right;">1.511 ns</td>
<td style="text-align: right;">1.413 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.3468</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">1,088 B</td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;byte&gt;</code></td>
<td>1000</td>
<td style="text-align: right;">262.99 ns</td>
<td style="text-align: right;">1.076 ns</td>
<td style="text-align: right;">0.954 ns</td>
<td style="text-align: right;">2.30</td>
<td style="text-align: right;">0.03</td>
<td style="text-align: right;">0.0610</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">192 B</td>
</tr>
<tr>
<td><code>PooledArrayBufferWriter&lt;byte&gt;</code></td>
<td>1000</td>
<td style="text-align: right;">393.58 ns</td>
<td style="text-align: right;">1.456 ns</td>
<td style="text-align: right;">1.291 ns</td>
<td style="text-align: right;">3.44</td>
<td style="text-align: right;">0.04</td>
<td style="text-align: right;">0.0353</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>FileBufferingWriter</code></td>
<td>1000</td>
<td style="text-align: right;">2,112.13 ns</td>
<td style="text-align: right;">12.391 ns</td>
<td style="text-align: right;">10.984 ns</td>
<td style="text-align: right;">18.48</td>
<td style="text-align: right;">0.24</td>
<td style="text-align: right;">0.0343</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>RecyclableMemoryStream</code></td>
<td>1000</td>
<td style="text-align: right;">2,485.95 ns</td>
<td style="text-align: right;">12.796 ns</td>
<td style="text-align: right;">11.970 ns</td>
<td style="text-align: right;">21.73</td>
<td style="text-align: right;">0.28</td>
<td style="text-align: right;">0.1183</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">376 B</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;byte&gt;</code></td>
<td>10000</td>
<td style="text-align: right;">771.29 ns</td>
<td style="text-align: right;">2.057 ns</td>
<td style="text-align: right;">1.823 ns</td>
<td style="text-align: right;">0.32</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.0811</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">256 B</td>
</tr>
<tr>
<td><code>PooledArrayBufferWriter&lt;byte&gt;</code></td>
<td>10000</td>
<td style="text-align: right;">1,293.53 ns</td>
<td style="text-align: right;">7.453 ns</td>
<td style="text-align: right;">6.224 ns</td>
<td style="text-align: right;">0.53</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.0343</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>MemoryStream</code></td>
<td>10000</td>
<td style="text-align: right;">2,419.10 ns</td>
<td style="text-align: right;">21.564 ns</td>
<td style="text-align: right;">19.116 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">9.8343</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">30,880 B</td>
</tr>
<tr>
<td><code>RecyclableMemoryStream</code></td>
<td>10000</td>
<td style="text-align: right;">2,891.81 ns</td>
<td style="text-align: right;">11.367 ns</td>
<td style="text-align: right;">9.492 ns</td>
<td style="text-align: right;">1.19</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: right;">0.1183</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">376 B</td>
</tr>
<tr>
<td><code>FileBufferingWriter</code></td>
<td>10000</td>
<td style="text-align: right;">3,004.68 ns</td>
<td style="text-align: right;">13.759 ns</td>
<td style="text-align: right;">12.870 ns</td>
<td style="text-align: right;">1.24</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: right;">0.0343</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;byte&gt;</code></td>
<td>100000</td>
<td style="text-align: right;">5,122.79 ns</td>
<td style="text-align: right;">27.198 ns</td>
<td style="text-align: right;">25.441 ns</td>
<td style="text-align: right;">0.08</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.1373</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">448 B</td>
</tr>
<tr>
<td><code>RecyclableMemoryStream</code></td>
<td>100000</td>
<td style="text-align: right;">7,108.29 ns</td>
<td style="text-align: right;">30.354 ns</td>
<td style="text-align: right;">25.347 ns</td>
<td style="text-align: right;">0.11</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.1144</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">376 B</td>
</tr>
<tr>
<td><code>PooledArrayBufferWriter&lt;byte&gt;</code></td>
<td>100000</td>
<td style="text-align: right;">8,401.60 ns</td>
<td style="text-align: right;">41.469 ns</td>
<td style="text-align: right;">38.790 ns</td>
<td style="text-align: right;">0.13</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.0305</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>MemoryStream</code></td>
<td>100000</td>
<td style="text-align: right;">65,821.24 ns</td>
<td style="text-align: right;">781.429 ns</td>
<td style="text-align: right;">692.716 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">41.6260</td>
<td style="text-align: right;">41.6260</td>
<td style="text-align: right;">41.6260</td>
<td style="text-align: right;">260,356 B</td>
</tr>
<tr>
<td><code>FileBufferingWriter</code></td>
<td>100000</td>
<td style="text-align: right;">130,246.81 ns</td>
<td style="text-align: right;">2,765.125 ns</td>
<td style="text-align: right;">8,109.632 ns</td>
<td style="text-align: right;">1.94</td>
<td style="text-align: right;">0.09</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">480 B</td>
</tr>
<tr>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
<tr>
<td><code>RecyclableMemoryStream</code></td>
<td>1000000</td>
<td style="text-align: right;">50,008.15 ns</td>
<td style="text-align: right;">224.449 ns</td>
<td style="text-align: right;">209.950 ns</td>
<td style="text-align: right;">0.06</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.3052</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">1,008 B</td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;byte&gt;</code></td>
<td>1000000</td>
<td style="text-align: right;">51,783.54 ns</td>
<td style="text-align: right;">356.691 ns</td>
<td style="text-align: right;">316.197 ns</td>
<td style="text-align: right;">0.06</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.1831</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">640 B</td>
</tr>
<tr>
<td><code>PooledArrayBufferWriter&lt;byte&gt;</code></td>
<td>1000000</td>
<td style="text-align: right;">83,773.13 ns</td>
<td style="text-align: right;">430.674 ns</td>
<td style="text-align: right;">402.853 ns</td>
<td style="text-align: right;">0.09</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">112 B</td>
</tr>
<tr>
<td><code>FileBufferingWriter</code></td>
<td>1000000</td>
<td style="text-align: right;">736,273.23 ns</td>
<td style="text-align: right;">12,760.737 ns</td>
<td style="text-align: right;">11,312.061 ns</td>
<td style="text-align: right;">0.82</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">481 B</td>
</tr>
<tr>
<td><code>MemoryStream</code></td>
<td>1000000</td>
<td style="text-align: right;">899,134.70 ns</td>
<td style="text-align: right;">6,252.141 ns</td>
<td style="text-align: right;">5,542.360 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">499.0234</td>
<td style="text-align: right;">499.0234</td>
<td style="text-align: right;">499.0234</td>
<td style="text-align: right;">2,095,744 B</td>
</tr>
</tbody>
</table>
<h1 id="typemap">TypeMap</h1>
<p><a class="xref" href="api/DotNext.Collections.Specialized.TypeMap-1.html">TypeMap&lt;TValue&gt;</a> and <a class="xref" href="api/DotNext.Collections.Specialized.ConcurrentTypeMap-1.html">ConcurrentTypeMap&lt;TValue&gt;</a> are specialized dictionaries where the keys are represented by the types passed as generic arguments. The are optimized in a way to be more performant than classic <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2">Dictionary&lt;Type,TValue&gt;</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2">ConcurrentDictionary&lt;Type,TValue&gt;</a>. <a href="https://github.com/dotnet/dotNext/blob/master/src/DotNext.Benchmarks/Collections/Specialized/TypeMapBenchmark.cs">This benchmark</a> demonstrates efficiency of the specialized collections:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TypeMap</code>, <code>Set</code> + <code>TryGetValue</code></td>
<td style="text-align: right;">1.860 ns</td>
<td style="text-align: right;">0.0173 ns</td>
<td style="text-align: right;">0.0162 ns</td>
</tr>
<tr>
<td><code>Dictionary</code>, <code>Set</code> + <code>TryGetValue</code></td>
<td style="text-align: right;">34.212 ns</td>
<td style="text-align: right;">0.1182 ns</td>
<td style="text-align: right;">0.1048 ns</td>
</tr>
<tr>
<td><code>ConcurrentTypeMap</code>, <code>Set</code> + <code>TryGetValue</code></td>
<td style="text-align: right;">20.773 ns</td>
<td style="text-align: right;">0.1711 ns</td>
<td style="text-align: right;">0.1600 ns</td>
</tr>
<tr>
<td><code>ConcurrentDictionary</code>, <code>Set</code> + <code>TryGetValue</code></td>
<td style="text-align: right;">58.532 ns</td>
<td style="text-align: right;">0.2534 ns</td>
<td style="text-align: right;">0.2247 ns</td>
</tr>
<tr>
<td><code>ConcurrentTypeMap</code>, <code>GetOrAdd</code></td>
<td style="text-align: right;">10.064 ns</td>
<td style="text-align: right;">0.0572 ns</td>
<td style="text-align: right;">0.0535 ns</td>
</tr>
<tr>
<td><code>ConcurrentDictionary</code>, <code>GetOrAdd</code></td>
<td style="text-align: right;">16.246 ns</td>
<td style="text-align: right;">0.1248 ns</td>
<td style="text-align: right;">0.1042 ns</td>
</tr>
</tbody>
</table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/benchmarks.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>
          
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In This Article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
              Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
              
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="styles/toggle-theme.js"></script>
      </footer>    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
