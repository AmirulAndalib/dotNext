<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Clustered ASP.NET Core Microservices | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Clustered ASP.NET Core Microservices | .NEXT ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="clustered-aspnet-core-microservices">Clustered ASP.NET Core Microservices</h1>

<p>.NEXT provides fully-featured implementation of cluster computing infrastructure for microservices constructed on top of ASP.NET Core. This implementation consists of the following features:</p>
<ul>
<li>Point-to-point messaging between microservices organized through HTTP</li>
<li>Consensus algorithm is Raft and all necessary communication for this algorithm is based on HTTP</li>
<li>Replication according with Raft algorithm is fully supported. In-memory audit trail is used by default.</li>
</ul>
<p>In this implementation, Web application treated as cluster node. The following example demonstrates how to turn ASP.NET Core application into cluster node:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler();	//informs that processing pipeline should handle Raft-specific requests
    }

    public void ConfigureServices(IServiceCollection services)
    {
    }
}

IHost host = new HostBuilder()
    .ConfigureWebHost(webHost =&gt; webHost
        .UseKestrel(options =&gt; options.ListenLocalhost(80))
        .UseStartup&lt;Startup&gt;()
    )
    .JoinCluster()  //registers all necessary services required for normal cluster node operation
    .Build();
</code></pre>
<p>Raft algorithm requires dedicated HTTP endpoint for internal purposes. There are two possible ways to expose necessary endpoint:</p>
<ul>
<li><strong>Hosted Mode</strong> exposes internal endpoint at different port because dedicated <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> is used</li>
<li><strong>Embedded Mode</strong> exposes internal endpoint at the same port as underlying web application</li>
</ul>
<p>The necessary mode depends on your requirements and network environment.</p>
<h1 id="dependency-injection">Dependency Injection</h1>
<p>Web application component can request the following service from ASP.NET Core DI container:</p>
<ul>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster/ICluster">ICluster</a></li>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IRaftCluster">IRaftCluster</a> represents Raft-specific version of <code>ICluster</code> interface</li>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Messaging/IMessageBus">IMessageBus</a> for point-to-point messaging between nodes</li>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster/IExpandableCluster">IExpandableCluster</a> for tracking changes in cluster membership</li>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Replication/IReplicationCluster%601">IReplicationCluster&lt;IRaftLogEntry&gt;</a> to work with audit trail used for replication. <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IRaftLogEntry">IRaftLogEntry</a> is Raft-specific representation of the record in the audit trail</li>
<li><a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Replication/IReplicationCluster">IReplicationCluster</a> to work with audit trail in simplified manner</li>
</ul>
<h1 id="configuration">Configuration</h1>
<p>The application should be configured properly to work as a cluster node. The following JSON represents example of configuration:</p>
<pre><code class="lang-json">{
	&quot;partitioning&quot; : false,
	&quot;lowerElectionTimeout&quot; : 150,
	&quot;upperElectionTimeout&quot; : 300,
	&quot;members&quot; : [&quot;http://localhost:3262&quot;, &quot;http://localhost:3263&quot;, &quot;http://localhost:3264&quot;],
	&quot;metadata&quot; :
	{
		&quot;key&quot;: &quot;value&quot;
	},
	&quot;allowedNetworks&quot; : [&quot;127.0.0.0&quot;, &quot;255.255.0.0/16&quot;, &quot;2001:0db9::1/64&quot;],
	&quot;hostAddressHint&quot; : &quot;192.168.0.1&quot;,
	&quot;requestJournal&quot; :
	{
		&quot;memoryLimit&quot;: 5,
		&quot;expiration&quot;: &quot;00:00:10&quot;,
		&quot;pollingInterval&quot; : &quot;00:01:00&quot;
	},
	&quot;resourcePath&quot; : &quot;/cluster-consensus/raft&quot;,
	&quot;port&quot; : 3262,
	&quot;heartbeatThreshold&quot; : 0.5,
    &quot;requestTimeout&quot; : &quot;00:01:00&quot;,
    &quot;keepAliveTimeout&quot;: &quot;00:02:00&quot;,
    &quot;requestHeadersTimeout&quot; : &quot;00:00:30&quot;
}
</code></pre>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Mode</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>partitioning</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>false</td>
<td><code>true</code> if partitioning supported. In this case, each cluster partition may have its own leader, i.e. it is possible to have more that one leader for external observer. However, single partition cannot have more than 1 leader. <code>false</code> if partitioning is not supported and only one partition with majority of nodes can have leader. Note that cluster may be totally unavailable even if there are operating members presented</td>
</tr>
<tr>
<td>lowerElectionTimeout, upperElectionTimeout</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>150, 300</td>
<td>Defines range for election timeout (in milliseconds) which is picked randomly inside of it for each cluster member. If cluster node doesn't receive heartbeat from leader node during this timeout then it becomes a candidate and start a election. The recommended value for  <em>upperElectionTimeout</em> is <code>2  X lowerElectionTimeout</code></td>
</tr>
<tr>
<td>members</td>
<td>Hosted, Embedded</td>
<td>Yes</td>
<td>N/A</td>
<td>An array of all cluster nodes. This list must include local node. DNS name cannot be used as host name in URL except <code>localhost</code>. Only IP address is allowed</td>
</tr>
<tr>
<td>allowedNetworks</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>Empty list which means that all networks are allowed</td>
<td>List of networks with other nodes which a part of single cluster. This property can be used to restrict unathorized requests to the internal endpoint responsible for handling Raft messages</td>
</tr>
<tr>
<td>metadata</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>empty dictionary</td>
<td>A set of key/value pairs to be associated with cluster node. The metadata is queriable through <code>IClusterMember</code> interface</td>
</tr>
<tr>
<td>openConnectionForEachRequest</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>false</td>
<td><code>true</code> to create TCP connection every time for each outbound request. <code>false</code> to use HTTP KeepAlive</td>
</tr>
<tr>
<td>clientHandlerName</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>raftClient</td>
<td>The name to be passed into <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a> to create <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> used by Raft client code</td>
</tr>
<tr>
<td>resourcePath</td>
<td>Embedded</td>
<td>No</td>
<td>/cluster-consensus/raft</td>
<td>Defines relative path to the endpoint responsible for handling internal Raft messages</td>
</tr>
<tr>
<td>port</td>
<td>Hosted</td>
<td>No</td>
<td>32999</td>
<td>Defines the port number that the internal endpoint handler is listening to.</td>
</tr>
<tr>
<td>requestJournal:memoryLimit</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>10</td>
<td>The maximum amount of memory (in MB) utilized by internal buffer used to track duplicate messages</td>
</tr>
<tr>
<td>requestJournal:expiration</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>00:00:10</td>
<td>The eviction time of the record containing unique request identifier</td>
</tr>
<tr>
<td>requestJournal:pollingInterval</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>00:01:00</td>
<td>Gets the maximum time after which the buffer updates its memory statistics</td>
</tr>
<tr>
<td>hostAddressHint</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>N/A</td>
<td>Allows to specify real IP address of the host where cluster node has been launched. Usually it is needed when node executed inside of Docker container. If this parameter is not specified then cluster node may fail to detect itself because network interfaces inside of Docker container have different addresses in comparison with real host network interfaces. The value can be defined at container startup time, e.g. <code>docker container run -e &quot;member-config:hostAddressHint=$(hostname -i)&quot;</code></td>
</tr>
<tr>
<td>hostNameHint</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>N/A</td>
<td>Allows to specify host name of node where cluster member has been launched. Usually it is needed when node executed inside of Docker container. If this parameter is not specified then cluster node may fail to detect itself because network interfaces inside of Docker container have different addresses in comparison with real host network interfaces. The value can be defined at container startup time, e.g. <code>docker container run -e &quot;member-config:hostNameHint=$(hostname)&quot;</code></td>
</tr>
<tr>
<td>heartbeatThreshold</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>0.5</td>
<td>Specifies frequency of heartbeat messages generated by leader node to inform follower nodes about its leadership. The range is (0, 1). The lower the value means that the messages are generated more frequently and vice versa.</td>
</tr>
<tr>
<td>protocolVersion</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td><code>auto</code></td>
<td>HTTP protocol version that should be used for communication between members. Possible values are <code>auto</code>, <code>http1</code>, <code>http2</code>, <code>http3</code></td>
</tr>
<tr>
<td>requestHeadersTimeout</td>
<td>Hosted</td>
<td>No</td>
<td>30 seconds</td>
<td>The maximum amount of time the server will spend receiving request headers</td>
</tr>
<tr>
<td>keepAliveTimeout</td>
<td>Hosted</td>
<td>No</td>
<td>2 minutes</td>
<td>TCP keep-alive timeout</td>
</tr>
<tr>
<td>requestTimeout</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td><code>upperElectionTimeout</code></td>
<td>Request timeout used to access cluster members across the network using HTTP client</td>
</tr>
<tr>
<td>rpcTimeout</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td><code>upperElectionTimeout</code> / 2</td>
<td>Request timeout used to send Raft-specific messages to cluster members. Must be less than or equal to <em>requestTimeout</em> parameter</td>
</tr>
<tr>
<td>standby</td>
<td>Hosted, Embedded</td>
<td>No</td>
<td>false</td>
<td><strong>true</strong> to prevent election of the cluster member as a leader. It's useful to configure nodes available for read-only operations</td>
</tr>
</tbody>
</table>
<p><code>requestJournal</code> configuration section is rarely used and useful for high-load scenario only.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Usually, real-world ASP.NET Core application hosted on <code>0.0.0.0</code>(IPv4) or <code>::</code>(IPv6). When testing locally, use explicit loopback IP instead of <code>localhost</code> as host name for all nodes in <code>members</code> section.</p>
</div>
<p>Choose <code>lowerElectionTimeout</code> and <code>upperElectionTimeout</code> according with the quality of your network. If values are small then you get frequent elections and migration of leader node.</p>
<h2 id="runtime-hook">Runtime Hook</h2>
<p>The service implementing <code>IRaftCluster</code> is registered as singleton service. The service starts receiving Raft-specific messages immediately. Therefore, you can loose some events raised by the service such as <code>LeaderChanged</code> at starting point. To avoid that, you can implement <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IClusterMemberLifetime">IClusterMemberLifetime</a> interface and register implementation as singleton.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using System.Collections.Generic;

internal sealed class MemberLifetime : IClusterMemberLifetime
{
	private static void LeaderChanged(ICluster cluster, IClusterMember leader) {}

	void IClusterMemberLifetime.Initialize(IRaftCluster cluster, IDictionary&lt;string, string&gt; metadata)
	{
		metadata[&quot;key&quot;] = &quot;value&quot;;
		cluster.LeaderChanged += LeaderChanged;
	}

	void IClusterMemberLifetime.Shutdown(IRaftCluster cluster)
	{
		cluster.LeaderChanged -= LeaderChanged;
	}
}
</code></pre>
<p>Additionally, the hook can be used to modify metadata of the local cluster member.</p>
<p>In some hosting environments with network virtualization it may be hard to detect the address of the node by itself. In this case, it's possible to provider custom selector for the local node. To do that, you need to implement <code>LocalMemberSelector</code> property of <code>IClusterMemberLifetime</code> interface:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

internal sealed class MemberLifetime : IClusterMemberLifetime
{
	private static async ValueTask&lt;bool&gt; IsLocal(IRaftClusterMember member, CancellationToken token)
    {
        var addresses = await Dns.GetHostAddressesAsync(Dns.GetHostName());
        if (member.EndPoint is DnsEndPoint dnsEndPoint)
        {
            var memberAddresses = await Dns.GetHostAddressesAsync(dnsEndPoint.Host);
            return addresses.Intersect(memberAddresses).Any();
        }

        return addresses.Any(a =&gt; a.Equals(member.EndPoint));
    }

    Func&lt;IRaftClusterMember, CancellationToken, ValueTask&lt;bool&gt;&gt;? IClusterMemberLifetime.LocalMemberSelector
        =&gt; new Func&lt;IRaftClusterMember, CancellationToken, ValueTask&lt;bool&gt;&gt;(IsLocal);
}
</code></pre>
<h2 id="http-client-behavior">HTTP Client Behavior</h2>
<p>.NEXT uses <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient">HttpClient</a> for communication between cluster nodes. The client itself delegates all operations to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessagehandler">HttpMessageHandler</a>. It's not recommended to use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclienthandler">HttpClientHandler</a> because it has inconsistent behavior on different platforms because relies on <em>libcurl</em>. Raft implementation uses <code>Timeout</code> property of <code>HttpClient</code> to establish request timeout. It is always defined as <code>upperElectionTimeout</code> by .NEXT infrastructure. To demonstrate inconsistent behavior let's introduce three cluster nodes: <em>A</em>, <em>B</em> and <em>C</em>. <em>A</em> and <em>B</em> have been started except <em>C</em>:</p>
<ul>
<li>On Windows the leader will not be elected even though the majority is present - 2 of 3 nodes are available. This is happening because Connection Timeout is equal to Response Timeout, which is equal to <code>upperElectionTimeout</code>.</li>
<li>On Linux everything is fine because Connection Timeout less than Response Timeout</li>
</ul>
<p>By default, Raft implementation uses <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler">SocketsHttpHandler</a>. However, the handler can be overridden using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a>. You can implement this interface manually and register its implementation as singleton. .NEXT tries to use this interface if it is registered as a factory of custom <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessagehandler">HttpMessageHandler</a>. The following example demonstrates how to implement this interface and create platform-independent version of message invoker:</p>
<pre><code class="lang-csharp">using System;
using System.Net.Http;

internal sealed class RaftClientHandlerFactory : IHttpMessageHandlerFactory
{
	public HttpMessageHandler CreateHandler(string name) =&gt; new SocketsHttpHandler { ConnectTimeout = TimeSpan.FromMilliseconds(100) };
}
</code></pre>
<p>In practice, <code>ConnectTimeout</code> should be equal to <code>lowerElectionTimeout</code> configuration property. Note that <code>name</code> parameter is equal to the <code>clientHandlerName</code> configuration property when handler creation is requested by Raft implementation.</p>
<h1 id="hosted-mode">Hosted Mode</h1>
<p>This mode allows to create separated <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> used for hosting Raft-specific stuff. As a result, Raft implementation listens on the port that differs from the port of underlying Web application.</p>
<p>The following example demonstrates this approach:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Hosting;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

IHost host = new HostBuilder()
    .ConfigureWebHost(webHost =&gt; webHost
        .UseKestrel(options =&gt; options.ListenLocalhost(80))
        .UseStartup&lt;Startup&gt;()
    )
    .JoinCluster()  //registers all necessary services required for normal cluster node operation
    .Build();
</code></pre>
<p>Note that <code>JoinCluster</code> method declared in <code>DotNext.Net.Cluster.Consensus.Raft.Http.Hosting</code> namespace and should be called after <code>ConfigureWebHost</code>. Otherwise, the behavior of this method is undefined.</p>
<p>By default, .NEXT uses Kestrel web server to serve Raft requests. However, it is possible to configure dedicated host manually. To do that, you need to register singleton service implementing <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft.Http.Hosting/IDedicatedHostBuilder">IDedicatedHostBuilder</a> interface. In this case, <code>port</code> configuration property will be ignored.</p>
<p><code>JoinCluster</code> method has overloads that allow to specify custom configuration section containing configuration of local node.</p>
<h1 id="embedded-mode">Embedded Mode</h1>
<p>Embedded mode shares the same <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> and port with underlying Web Application. To serve Raft-specific requests the implementation uses dedicated endpoint <code>/cluster-consensus/raft</code> that can be changed through configuration parameter. The following example demonstrates how to setup embedded mode:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler();	//informs that processing pipeline should handle Raft-specific requests
    }

    public void ConfigureServices(IServiceCollection services)
    {
    }
}

IHost host = new HostBuilder()
    .ConfigureWebHost(webHost =&gt; webHost
        .UseKestrel(options =&gt; options.ListenLocalhost(80))
        .UseStartup&lt;Startup&gt;()
    )
    .JoinCluster()  //registers all necessary services required for normal cluster node operation
    .Build();
</code></pre>
<p>Note that <code>JoinCluster</code> declared in <code>DotNext.Net.Cluster.Consensus.Raft.Http.Embedding</code> namespace and should be called after <code>ConfigureWebHost</code>. Otherwise, the behavior of this method is undefined.</p>
<p><code>JoinCluster</code> method has overloads that allow to specify custom configuration section containing configuration of local node.</p>
<p><code>UseConsensusProtocolHandler</code> method should be called before registration of any authentication/authorization middleware.</p>
<h1 id="redirection-to-leader">Redirection to Leader</h1>
<p>Now cluster of ASP.NET Core applications can receive requests from outside. Some of these requests may be handled by leader node only. .NEXT cluster programming model provides a way to automatically redirect request to leader node if it was originally received by follower node. The redirection is organized with help of <em>307 Temporary Redirect</em> status code. Every follower node knows the actual address of the leader node. If cluster or its partition doesn't have leader then node returns <em>503 Service Unavailable</em>.</p>
<p>Automatic redirection is provided by <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft.Http/LeaderRouter">LeaderRouter</a> class. You can specify endpoint that should be handled by leader node with <code>RedirectToLeader</code> method.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http;
using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public void ConfigureServices(IServiceCollection services)
    {
    }
}
</code></pre>
<p>This redirection can be transparent to actual client if you use reverse proxy server such as NGINX. Reverse proxy can automatically handle redirection without returning control to the client.</p>
<h2 id="custom-redirections">Custom Redirections</h2>
<p>It is possible to change default behavior of redirection where <em>301 Moved Permanently</em> status code is used. You can pass custom implementation into the optional parameter of <code>RedirectToLeader</code> method.</p>
<p>The following example demonstrates how to return <em>404 Not Found</em> and location of Leader node as its body.</p>
<pre><code class="lang-csharp">private static Task CustomRedirection(HttpResponse response, Uri leaderUri)
{
    response.StatusCode = StatusCodes.Status404NotFound;
    return response.WriteAsync(leaderUri.AbsoluteUri);
}

public void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
        .RedirectToLeader(&quot;/endpoint1&quot;, redirection: CustomRedirection);
}
</code></pre>
<p>The customized redirection should be as fast as possible and don't block the caller.</p>
<h2 id="port-mapping">Port mapping</h2>
<p>Redirection mechanism trying to construct valid URI of the leader node based on its actual IP address. Identification of the address is not a problem unlike port number. The infrastructure cannot use the port if its <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webhost">WebHost</a> because of Hosted Mode or the port from the incoming <code>Host</code> header because it can be rewritten by reverse proxy. The only way is to use the inbound port of the TCP listener responsible for handling all incoming HTTP requests. It is valid for the non-containerized environment. Inside of the container the ASP.NET Core application port is mapped to the externally visible port which not always the same. In this case you can specify port for redirections explicitly as follows:</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
      .RedirectToLeader(&quot;/endpoint1&quot;, applicationPortHint: 3265);
}
</code></pre>
<h1 id="messaging">Messaging</h1>
<p>.NEXT extension for ASP.NET Core supports messaging beween nodes through HTTP out-of-the-box. However, the infrastructure don't know how to handle custom messages. Therefore, if you want to utilize this functionality then you need to implement <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Messaging/IInputChannel">IInputChannel</a> interface.</p>
<p>Messaging inside of cluster supports redirection to the leader as well as for external client. But this mechanism implemented differently and exposed as <code>IInputChannel</code> interface via <code>LeaderRouter</code> property of <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Messaging/IMessageBus">IMessageBus</a> interface.</p>
<h1 id="replication">Replication</h1>
<p>Raft algorithm requires additional persistent state in order to basic audit trail. This state is represented by <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IPersistentState">IPersistentState</a> interface. By default, it is implemented as <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/ConsensusOnlyState">ConsensusOnlyState</a> which is suitable only for applications that doesn't have replicated state. If your application has it then use <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/PersistentState">PersistentState</a> class or implement this interface manually and use reliable storage such as disk. The implementation can be injected explicitly via <code>AuditTrail</code> property of <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IRaftCluster">IRaftCluster</a> interface or implicitly via Dependency Injection. The explicit should be done inside of the user-defined implementation of <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IClusterMemberLifetime">IClusterMemberLifetime</a> interface registered as a singleton service in ASP.NET Core application. The implicit injection requires registration of singleton service which implements <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IPersistentState">IPersistentState</a> interface.</p>
<h2 id="reliable-state">Reliable State</h2>
<p>Information about reliable persistent state which uses disk for storing write ahead log located in the separated <a href="wal.html">article</a>. However, its usage turns your microservice into stateful service because its state persisted on disk. Consider this fact if you are using containerization technologies such as Docker or LXC.</p>
<h1 id="service-discovery">Service Discovery</h1>
<p>The clustered application may be deployed in various hosting environments and container orchestrators. In case of classic deployment on virtual machines or containers the configuration of cluster members supplied via configuration file or any other configuration providers with the support of hot reloading in case when you have added or removed cluster members. There is another way to do the service discovery. <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/IMemberDiscoveryService">IMemberServiceDiscovery</a> interface represents extension point at which you can implement your own mechanism of tracking cluster nodes. This way is much more simplier in comparison to custom <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationprovider">IConfigurationProvider</a>. All you need is to implement this interface and register it as singleton service with <code>UseDiscoveryService</code> extension method or manually.</p>
<p>Custom discovery mechanism is applicable when your hosting environment has its own discovery mechanism. For instance, you have <a href="https://www.consul.io/">Consul</a> or Kubernetes. Kubernetes has its own mechanism for service discovery if you use <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> abstraction configured for your nodes.</p>
<h1 id="metrics">Metrics</h1>
<p>It is possible to measure runtime metrics of Raft node internals using <a class="xref" href="https://fuget.org/packages/DotNext.AspNetCore.Cluster/3.1.0/lib/net5.0/DotNext.AspNetCore.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft.Http/HttpMetricsCollector">HttpMetricsCollector</a> class. The reporting mechanism is agnostic to the underlying metrics delivery library such as <a href="https://github.com/AppMetrics/AppMetrics">AppMetrics</a>.</p>
<p>The class contains methods that are called automatically. You can override them and implement necessary reporting logic. By default, these methods do nothing.</p>
<p>The metrics collector should be registered as singleton service using Dependency Injection. However, the type of the service used for registration should of <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/MetricsCollector">MetricsCollector</a> type.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using DotNext.Net.Cluster.Consensus.Raft.Http;
using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class MyCollector : HttpMetricsCollector
{
	public override void ReportResponseTime(TimeSpan value)
    {
		//report response time of the cluster member
    } 

	public override void ReportBroadcastTime(TimeSpan value)
    {
		//report broadcast time measured during sending the request to all cluster members
    }
}

sealed class Startup 
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public void ConfigureServices(IServiceCollection services)
    {
		services.AddSingleton&lt;MetricsCollector, MyCollector&gt;();
    }
}
</code></pre>
<p>It is possible to derive directly from <a class="xref" href="https://fuget.org/packages/DotNext.Net.Cluster/3.1.0/lib/net5.0/DotNext.Net.Cluster.dll/DotNext.Net.Cluster.Consensus.Raft/MetricsCollector">MetricsCollector</a> if you don't need to receive metrics related to HTTP-specific implementation of Raft algorithm.</p>
<p>Implementation of reporting method should fast as possible or asynchronous. If reporting causes I/O operations synchronously then it affects the overall performance of Cluster library internals such as communication with other cluster members which is time-critical.</p>
<h1 id="development-and-debugging">Development and Debugging</h1>
<p>It may be hard to reproduce the real cluster on developer's machine. You may want to run your node in <em>Debug</em> mode and ensure that the node you're running is a leader node. To do that, you need to configure only one node in the list of cluster members.</p>
<h1 id="performance">Performance</h1>
<p>The wire format is highly optimized for transferring log entries during the replication process over the wire. The most performance optimizations should be performed when configuring persistent Write-Ahead Log.</p>
<h2 id="log-compaction">Log Compaction</h2>
<p><a href="(xref:DotNext.Net.Cluster.Consensus.Raft.PersistentState)">PersistentState</a> supports several log compaction modes. Some of them allow compaction in parallel with appending of new log entries. Read more <a href="wal.html">here</a> for more information about the available modes. <em>Background</em> compaction provides precise control over the compaction. There are few ways to control it:</p>
<ol>
<li>If you're using <code>UsePersistenceEngine</code> extension method for registering your engine based on <code>PersistentState</code> then .NEXT infrastructure automatically detects the configured compaction mode. If it is <em>Background</em> then it will register <em>compaction worker</em> as a background service in ASP.NET Core. This worker provides <em>incremental background compaction</em>. You can override this behavior by implementing <a class="xref" href="https://fuget.org/packages/DotNext.IO/3.1.0/lib/net5.0/DotNext.IO.dll/DotNext.IO.Log/ILogCompactionSupport">ILogCompactionSupport</a> in your persistence engine.</li>
<li>If you're registering persistence engine in DI container manually, you need to implement background compaction worker manually using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.backgroundservice.startasync">BackgroundService</a> class and call <code>ForceCompactionAsync</code> method in the overridden <code>ExecuteAsync</code> method.</li>
</ol>
<p><em>Incremental background compaction</em> is the default strategy when <em>Background</em> compaction enabled. The worker just waits for the commit and checks whether <code>PersistentState.CompactionCount</code> property is greater than zero. If so, it calls <code>ForceCompactionAsync</code> with the compaction factor which is equal to 1. It provides minimal compaction of the log. As a result, the contention between the compaction worker and readers is minimal or close to zero.</p>
<h2 id="buffered-replication">Buffered Replication</h2>
<p>Replication process requires read access to the WAL. In case of <code>PersistentState</code> this means that no one can append new entries or execute log compaction. Receiver also need to write the received log entries. So the read lock time is the sum of the time needed for the transfer over the wire and the time needed to persist received log entries. The time needed for disk I/O can be removed completely if buffered replication is enabled.</p>
<p>The following example shows how to enable the buffering:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;

IServiceCollection services;
services.EnableBuffering(options =&gt; 
{
    MemoryThreshold = 10 * 1024
});
</code></pre>
<p>Each log entry which is less than 10 KB in size will be stored in memory before writing to the WAL. Log entries larger than 10 KB will be stored in the temporary files. These files will be deleted automatically in the end of the replication process.</p>
<h1 id="example">Example</h1>
<p>There is Raft playground represented by RaftNode application. You can find this app <a href="https://github.com/sakno/dotNext/tree/develop/src/examples/RaftNode">here</a>. This playground allows to test Raft consensus protocol in real world. Each instance of launched application represents cluster node. All nodes can be started using the following script:</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- http 3262
dotnet run -- http 3263
dotnet run -- http 3264
</code></pre>
<p>Every instance should be launched in separated Terminal session. After that, you will see diagnostics messages in <code>stdout</code> about election process. Press <em>Ctrl+C</em> in the window related to the leader node and ensure that new leader will be elected.</p>
<p>Optionally, you can test replication powered by persistent WAL. To do that, you need to specify the name of folder which is used to store Write Ahead Log files</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- http 3262 node1
dotnet run -- http 3263 node2
dotnet run -- http 3264 node3
</code></pre>
<p>Now you can see replication messages in each Terminal window. The replicated state stored in the <code>node1</code>, <code>node2</code> and <code>node3</code> folders. You can restart one of the nodes and make sure that its state is recovered correctly.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/dotNext/blob/gh-pages/docs/features/cluster/aspnetcore.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
                <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
              </div>
          
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
