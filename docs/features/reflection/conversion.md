Type Conversion
====
.NET compilers recognize _op\_Implicit_ and _op\_Explicit_ methods as type cast operators. These methods are generated by C# compiler when for **implicit** and **explicit** operators respectively. Methods with special names cannot be called directly using their names from C# or VB.NET. DotNext allows to reflect type cast operators and call them through delegate instances. 

[Conversion](../../api/DotNext.Reflection.Conversion-2.yml) class provides strongly typed access to type cast operators even if these operators are not defined in the target class. For example, object of type _System.String_ can be converted to _IComparable&lt;String&gt;_ without **implicit** or **explicit** operator.
```csharp
using DotNext.Reflection;

decimal d = Conversion<int, decimal>.Converter(20); //Decimal.op_Implicit will be called
int i = Conversion<byte, int>.Converter(1); //Byte.op_Implicit is not defined, however, byte can be converted into int
```

It is possible to check whether the one type can be converted into another:
```csharp
using DotNext.Reflection;

var supported = Conversion<int, decimal>.IsSupported;   //supported == true
```

The reflected typecast operation is represented by instance of delegate [Converter](https://docs.microsoft.com/en-us/dotnet/api/system.converter-2).